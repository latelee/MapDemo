<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>地图综合示例</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        #map {
            width: 100vw;
            height: 100vh;
        }

        #inputPanel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            width: 180px; 
            background: white; 
            padding: 10px; 
            z-index: 1000;
            border: 1px solid #ccc;
        }
        #txtInput {
            width: 100%;
            height: 150px;
            font-family: monospace;
        }
        #txtOutput {
            width: 100%;
            height: 150px;
            font-family: monospace;
        }

        /* 右键菜单样式 */
        .context-menu {
                position: absolute;
                z-index: 1000;
                background: white;
                border: 1px solid #ccc;
                border-radius: 5px;
                box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
                padding: 0;
                display: none;
                width: 150px;
                transform: translate(-5px, -5px); /* 使菜单向左上方偏移 */
        }
        
        .context-menu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        
        .context-menu li {
            padding: 2px 15px;
            cursor: default; /* 菜单项也使用箭头光标 */
            /* border-bottom: 1px solid #eeee; */ /*不要横线*/
            transition: background 0.2s;
            font-size: 14px;
        }

        /* 分组分隔线 - 在第3项后添加较粗的分隔线 */
        /* .context-menu li:nth-child(3) {
            border-bottom: 2px solid #cccccc;
        }

        .context-menu li:nth-child(5) {
            border-bottom: 2px solid #cccccc;
        } */


        .context-menu li:last-child {
            border-bottom: none;
        }
        
        .context-menu li:hover {
            /* background: #efefef; */
            background: #f7f7f7;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div id="inputPanel">
        一个输入框 <textarea id="txtInput" placeholder="请输入内容..."></textarea>
        一个输出框<textarea id="txtOutput" placeholder="请等待内容输出..."></textarea>
        <select id="functionSelect" onchange="onFunctionChange()">
            <option value="坐标定位">坐标定位</option>
            <option value="自定义标记">自定义标记</option>
            <option value="自定义标记1">自定义标记1</option>
            <option value="绘制圆形">绘制圆形</option>
            <option value="绘制矩形">绘制矩形</option>
            <option value="绘制折线">绘制折线</option>
            <option value="绘制多边形">绘制多边形</option>
            <option value="显示GeoJSON-默认">显示GeoJSON-默认</option>
            <option value="显示GeoJSON-自定义">显示GeoJSON-自定义</option>
            <option value="显示TopoJSON">显示TopoJSON</option>
            <option value="turfjs小功能测试">turfjs小功能测试</option>
            <option value="turfjs简化路线">turfjs简化路线</option>
        </select>

        <br><br>
        <button onclick="handleCmd()">提交</button>
        <button onclick="clearMap()">清除图层</button>

        <!-- 右键菜单 -->
        <div id="context-menu" class="context-menu">
            <ul>
                <li data-action="r-show-coords">显示经纬度</li>
                <li data-action="r-marker-start">自定义起点</li>
                <li data-action="r-marker-end">自定义终点</li>
            </ul>
        </div>
    </div>
</body>

<link rel="stylesheet" href="mymap/leaflet/dist/leaflet.css" />
<script src="mymap/leaflet/dist/leaflet.js"></script>
<script src="mymap/maptool/topojson-client.min.js"></script>
<!-- <script src="mymap/maptool/turf-6.5.0.min.js"></script> -->
<script src="mymap/maptool/turf-7.2.0.min.js"></script>

<script src="utils.js?v=a33"></script>

<!-- 本地geojson，直接引入-->
<script src="mymap/data/china.js"></script>
<script src="mymap/data/china_simple.js"></script>
<script src="mymap/data/gxData.js"></script>
<script src="mymap/data/naningData.js"></script>

<script src="mymap/data/450000-广西壮族自治区.js"></script>

<script type="text/javascript">

//////////////////////////////////

var currentLayer = null;

const multiLayers = [];

// 清除所有图层
function clearAllLayers() {
    multiLayers.forEach(layer => {
        if (layer && mymap.hasLayer(layer)) {
            mymap.removeLayer(layer);
        }
    });
    multiLayers.length = 0;
}

// 添加图层
function addToLayers(layer) {
    if (layer) {
        multiLayers.push(layer);
        mymap.addLayer(layer);
    }
}

clearAllLayers(); // 刷新时，先清除

// 本函数仅是显示输入示例，无实例用处
function onFunctionChange() {
    const select = document.getElementById('functionSelect');
    const input = document.getElementById('txtInput');
    const output = document.getElementById('txtOutput');

    input.placeholder = "使用说明见下框，可复制进行测试"
    
    switch(select.value) {
    case '坐标定位':
        output.value = '请输入坐标 [经度, 纬度]\n示例：108.331032, 22.829035';
        break;
    case '自定义标记':
        output.value = '本功能固定经纬度位置';
        input.value = "任意字符"
        break;
    case '自定义标记1':
        output.value = '本功能固定经纬度位置';
        input.value = "任意字符"
        break;
    case '绘制圆形':
        output.value = '请输入圆心坐标经纬度和半径（单位为米），以逗号隔开\n示例：108.414116,22.880920, 3000';
        break;
    case '绘制矩形':
        output.value = '请输入矩形左下角、右上角2组经纬度字符串，以逗号隔开\n示例：104.450893, 20.899288, 112.06185, 26.385566';
        break;
    case '绘制折线':
        output.value = `请输入折线经纬度字符串数组，每组用分号隔开\n格式：lng,lat;lng,lat;\n示例：108.482437,22.857195;
108.479004,22.818593;
108.405533,22.798338;`;
        break;
    case '绘制多边形':
        output.value = `请输入多边形经纬度字符串数组，每组用分号隔开\n格式：lng,lat;lng,lat;示例：108.064957,22.870481;
108.084183,22.864155;
108.109589,22.831883;
108.128128,22.840426;
108.130188,22.828086;
108.114738,22.812897;
108.112335,22.802136;
108.169327,22.758770;
108.202801,22.778872;
108.190269,22.813213;
108.160057,22.842958;
108.118515,22.848020;
108.103409,22.875226;
108.071823,22.878389;
`;
        break;
    case '显示GeoJSON-默认':
        output.value = '请输入 GeoJSON 数据...\n示例：{"type":"FeatureCollection","features":[...]}';
        break;
    case '显示GeoJSON-自定义':
        output.value = '请输入 GeoJSON 数据...\n示例：{"type":"FeatureCollection","features":[...]}';
        break;
    case '显示TopoJSON':
        output.value = '请输入 TopoJson 数据...\示例';
        break;
    case 'turfjs小功能测试':
        output.value = '本功能固定测试turfs接口';
        input.value = "任意字符"
        break;
    case 'turfjs简化路线':
        output.value = '请输入 GeoJSON 数据...\n示例：{"type":"FeatureCollection","features":[...]}';
        break;
    }
}

// 统一处理命令
function handleCmd() {
    const select = document.getElementById('functionSelect');
    const input = document.getElementById('txtInput').value;
    const output = document.getElementById('txtOutput');
    var info = "未未定返回信息"

    if (input=="") {
        document.getElementById('txtOutput').value = "输入内容为空";
        return;
    }

    // 先处理自定义的字符串
    var info = handleCustomCmd(input);
    if (info != "")
    {
        output.value = info;
        return;
    }

    try {
        switch(select.value) {
        case '坐标定位':
            info = flyToLocation(input);
            break;
        case '自定义标记':
            info = customMarker(input);
            break;
        case '自定义标记1':
            info = customMarker1(input);
            break;
        case '绘制圆形':
            info = drawCircle(input);
            break;
        case '绘制矩形':
            info = drawRectangle(input);
            break;
        case '绘制折线':
            info = drawPolyLine(input);
            break;
        case '绘制多边形':
            info = drawPolygon(input);
            break;
        case '显示GeoJSON-默认':
            info = showGeoJSON(input);
            break;
        case '显示GeoJSON-自定义':
            info = showMyGeoJSON(input);
            break;
        case '显示TopoJSON':
            info = showMyTopoSON(input);
        break;
        case 'turfjs小功能测试':
            info = showMyTurf(input);
        break;
        case 'turfjs简化路线':
            info = showSimplifyTurf(input);
        break;
        }
        
        output.value = info;
    } catch (error) {
        output.value = `错误: ${error.message}`;
    }
}

function handleCustomCmd(inputStr) {
    var info = ""
    try {
        switch(inputStr) {
        case 'foo':
            info = ""
            break;
        default:
            info = ""
            break;
        }
    } catch (error) {
        info = `处理自定义命令错误: ${error.message}`;
    }

    return info
}

function showGeoJSON(inputStr) {
    try {
        const geojsonData = JSON.parse(inputStr);
        currentLayer = L.geoJSON(geojsonData).addTo(mymap);

        addToLayers(currentLayer);
        
        // 自动调整地图视野到恰当的位置
        mymap.fitBounds(currentLayer.getBounds());

        return "GeoJSON 加载成功";
    } catch (error) {
        return 'GeoJSON 格式错误: ' + error.message;
    }
}

function showMyGeoJSON(inputStr) {
    try {
        const geojsonData = JSON.parse(inputStr);
        // console.log("geojsonData",geojsonData)
        currentLayer = drawOneLayer(geojsonData, {color: "#ff0000", weight: 2})

        addToLayers(currentLayer);
        
        // 自动调整地图视野到恰当的位置
        mymap.fitBounds(currentLayer.getBounds());

        return "GeoJSON 加载成功";
    } catch (error) {
        return 'GeoJSON 格式错误: ' + error.message;
    }
}

// 找到topoJson第一个对象
function autoConvertTopoToGeo(topoData) {
    const objectNames = Object.keys(topoData.objects);
    if (objectNames.length === 0) {
        throw new Error('TopoJSON 中没有找到任何对象');
    }

    const objectName = objectNames[0];

    return topojson.feature(topoData, topoData.objects[objectName]);
}

function showMyTopoSON(inputStr) {
    try {
        const topoData = JSON.parse(inputStr);

        const geoJSON = autoConvertTopoToGeo(topoData);

        // console.log("dddd", JSON.stringify(geoJSON))

        currentLayer = drawOneLayer(geoJSON, {color: "#ff0000", weight: 2})

        addToLayers(currentLayer);
        
        // 自动调整地图视野到恰当的位置
        mymap.fitBounds(currentLayer.getBounds());

        return "GeoJSON 加载成功";
    } catch (error) {
        return 'GeoJSON 格式错误: ' + error.message;
    }
}

/*
坐标定位
支持：
z,lng,lat  或 lng,lat
如不指定等级，按当前缩放等级
*/
function flyToLocation(inputStr) {
    // 以当前等级为默认等级
    z = mymap.getZoom();
    var lng, lat
    var vLine = inputStr.split(',')
    if (vLine.length == 2) {
        lng = parseFloat(vLine[0]);
        lat = parseFloat(vLine[1]);
        
    } else if (vLine.length == 3) {
        z = parseInt(vLine[0], 10);
        lng = parseFloat(vLine[1]);
        lat = parseFloat(vLine[2]);
    } else {
        return '参数不合规'
    }
    info = `坐标 ${lng}, ${lat}`
    const center = [lat, lng]
    var marker = L.marker(center, {})
    marker.bindPopup(info)
    addToLayers(marker)

    mymap.flyTo(center, z)

    return '定位成功'
}

function customMarker(inputStr) {
    // 自定义icon
    const LeafIcon = L.Icon.extend({
		options: {
			shadowUrl: 'mymap/images/leaf-shadow.png',
			iconSize:     [38, 95], // size of the icon
			shadowSize:   [50, 64], // size of the shadow
			iconAnchor:   [22, 94], // point of the icon which will correspond to marker's location
			shadowAnchor: [4, 62],  // the same for the shadow
			popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
		}
	});
	
    // 使用不同图片
	const greenIcon = new LeafIcon({iconUrl: 'mymap/images/leaf-green.png'});
	const redIcon = new LeafIcon({iconUrl: 'mymap/images/leaf-red.png'});
	const orangeIcon = new LeafIcon({iconUrl: 'mymap/images/leaf-orange.png'});

	const mGreen = L.marker([22.828368, 108.331842], {icon: greenIcon}).bindPopup('I am a green leaf.').addTo(mymap);
	const mOrange = L.marker([22.810998, 108.393173], {icon: orangeIcon}).bindPopup('I am an orange leaf.').addTo(mymap);
    const mRed = L.marker([22.738190,108.379440], {icon: redIcon}).bindPopup('I am a red leaf.').addTo(mymap);
	
    return '绘制成功'
}


function customMarker1(inputStr) {
    // 自定义icon
    const LeafIcon = L.Icon.extend({
		options: {
			iconSize:     [48, 48], // 图标文件尺寸
			iconAnchor:   [48/2, 48], // 图标锚点位置，需设置恰当的值使其位于标记的地理位置。
			popupAnchor:  [0, -48] // 弹出文字位置（相对iconAnchor）
		}
	});
	
    // 使用不同图片
	const startIcon = new LeafIcon({iconUrl: 'mymap/images/起点.png'});
	const endIcon = new LeafIcon({iconUrl: 'mymap/images/终点.png'});

	const startMarker = L.marker([22.827977, 108.331461], {icon: startIcon})
    startMarker.bindPopup('起点');
    startMarker.addTo(mymap);
	
    const endMarker = L.marker([22.828408, 108.332115], {icon: endIcon})
    endMarker.bindPopup('终点');
	endMarker.addTo(mymap);


    // 另一个测试
    const dropIcon = L.icon({
        iconUrl: 'mymap/images/水滴.png',
        iconSize:     [48, 48],
        iconAnchor:   [48/2, 0],
        popupAnchor:  [0, -48]
    })
    L.marker([22.828408, 108.332115], {icon: dropIcon}).bindPopup('一个水滴').addTo(mymap);

    mymap.flyTo([22.827977, 108.331461], 18)

    return '绘制成功'
}

function drawCircle(inputStr) {
    console.log('绘制圆形:', inputStr);

    z = mymap.getZoom();
    var lng, lat, radius;
    var vLine = inputStr.split(',')
    if (vLine.length == 3) {
        lng = parseFloat(vLine[0]);
        lat = parseFloat(vLine[1]);
        radius = parseInt(vLine[2], 10);
    } else {
        return '参数不合规'
    }

    var circle = L.circle([lat, lng], {
        color: 'red', // 边框颜色
        weight: 1,   // 边框宽度
        fillColor: '#f03000', // // 填充颜色
        fillOpacity: 0.2, // 填充透明度
        radius: radius // 半径（米）
    })

    addToLayers(circle);
    mymap.fitBounds(circle.getBounds());

    circle.bindPopup("<font color='red'>我是个圆</font>")

    return '绘制成功'
}

function drawRectangle(inputStr) {
    console.log('绘制矩形:', inputStr);

    const object = drawMyRectangle(inputStr, { color: "red", weight: 3})

    addToLayers(object)
    mymap.fitBounds(object.getBounds());

    return '绘制成功'
}

function drawPolyLine(inputStr) {
    console.log('绘制折线:', inputStr);

    const object = drawMyPolyLine(inputStr, { color: "red", weight: 3})

    addToLayers(object)
    mymap.fitBounds(object.getBounds());

    return '绘制成功'
}

// 绘制多边形的实现
function drawPolygon(inputStr) {
    console.log('绘制多边形:', inputStr);

    const object = drawMyPolygon(inputStr, { color: "red", weight: 3})

    addToLayers(object)
    mymap.fitBounds(object.getBounds());

    return '绘制成功'
}

function showMyTurf(inputStr) {
    var info = "";
    info += turf_demo1();
    // info += turf_demo2();
    // info += turf_demo3();
    // info += turf_demo4();
    // info += turf_demo5();
    return info;
}

// 简单接口
function turf_demo1() {
    var info = ""

    const points = [
        [108.397293,22.738823],
        [108.481064,22.724890]
    ];
    // 点
    // 注：turf.point 返回点，第二个参数可指定properties参数，drawOneLayer 函数会自动判断name，故加之
    const point1 = turf.point(points[0], {name: "五象湖公园"});
    var pointLayer1 = drawOneLayer(point1);
    addToLayers(pointLayer1);

    const point2 = turf.point(points[1], {name: "南宁园博园"});
    var pointLayer2 = drawOneLayer(point2);
    addToLayers(pointLayer2);

    // 计算两点间距离
    const disTurf = turf.distance(point1, point2, { units: 'kilometers' });
    info +=`2点间距离(turfs): ${disTurf.toFixed(3)} 公里\r\n`;

    const disLeaflet = calcDistance(points, "km")
    info +=`2点间距离(leaflet): ${disLeaflet.toFixed(3)} 公里\r\n`;

    // 线
    const linePoints = [
        [108.316269, 22.838212],
        [108.326569, 22.807200],
        [108.347168, 22.779347],
        [108.352661, 22.759720],
        [108.379440, 22.738190]
    ];

    var line = turf.lineString(
        // [
        //     [108.316269, 22.838212],
        //     [108.326569, 22.807200],
        //     [108.347168, 22.779347],
        //     [108.352661, 22.759720],
        //     [108.379440, 22.738190]
        // ],
        linePoints,
        {color: "#FF00FF", name: "折线"}
    );
    var lineLayer = drawOneLayer(line);
    addToLayers(lineLayer);

    // 可指定为miles或kilometers，默认后者，可不写
    var totalDistance = turf.length(line, { units: "kilometers"});

    info += `线段长度: ${totalDistance.toFixed(3)} 公里\r\n`
    
    const disLeaflet2 = calcDistance(linePoints, "km")
    info +=`线段长度(leaflet): ${disLeaflet2.toFixed(3)} 公里\r\n`;


    // 面
    const polygon = turf.polygon(
        [
            [
                [108.3, 22.86], 
                [108.4, 22.86], 
                [108.4, 22.9], 
                [108.3, 22.9], 
                [108.3, 22.86]
            ]
        ], {color: "#0000FF"}
    );

    var polygonLayer = drawOneLayer(polygon);
    addToLayers(polygonLayer);

    // 计算面积
    const area = turf.area(polygon); // 平方米
    info += `面积: ${area.toFixed(3)} 平方米`;

    return info
}

function turf_demo2() {
    var info = ""

    // 最小外接矩形
    var bbox = turf.bbox(gxGeoJson); // gxGeoJson 在 450000-广西壮族自治区.js 中定义
    // 从边界框创建多边形
    var polygon = turf.bboxPolygon(bbox, {}, {color: "#0000FF"});
    var polygonLayer = drawOneLayer(polygon);
    addToLayers(polygonLayer);

    info += `广西最小外接矩形为 ${bbox}\r\n`

    // 计算中心点
    const center = turf.center(gxGeoJson);
    const latlng = center.geometry.coordinates;
    const point = turf.point(latlng, {name: "中心点"});
    var pointLayer = drawOneLayer(point);
    addToLayers(pointLayer);
    
    info += `中心点为 ${latlng}\r\n`

    // 计算总面积
    var totalArea = turf.area(gxGeoJson);
    totalArea = totalArea / 10000000000;

    info += `广西总面积 ${totalArea.toFixed(3)} 万平方千米`

    return info
}


// 贝塞尔曲线测试 bezierSpline
function turf_demo3() {
    var info = ""

    // 坐标点
    var points = [
        [108.390427,22.922982],
        [108.476257,22.929306],
        [108.524323,22.895786],
        [108.500290,22.841376]
    ];
    // 原始线
    var line = turf.lineString(
        points,
        {color: "#0000FF", name: "折线"}
    );
    addToLayers(drawOneLayer(line));

    var line1 = turf.lineString(
        points,
    );
    var curved = turf.bezierSpline(line1, 
        {
            resolution: 1000, 
            sharpness: 0.5,
            properties: {color: "#FF0000", name: "折线"}
        }
    );
    addToLayers(drawOneLayer(curved));

    return info
}

// 空间关系判断
function turf_demo4() {
    var info = ""

    const points = [
        [108.481064,22.724890],
        [108.397293,22.738823]
    ];
    
    const point1 = turf.point(points[0], {name: "南宁园博园"});
    addToLayers(drawOneLayer(point1));

    const point2 = turf.point(points[1], {name: "五象湖公园"});
    addToLayers(drawOneLayer(point2));

    var line1 = turf.lineString(
        [
            [108.481064,22.724890],
            [108.397293,22.738823],
            [108.369827,22.774599]
        ], {color: "#0000FF"}
    );
    addToLayers(drawOneLayer(line1));

    // 判断点与线的关系
    const isPointOnLine1 = turf.booleanPointOnLine(point1, line1);
    // 不在线上的点
    const outPoint = turf.point([108.45,22.77], {name: "其它点"});
    addToLayers(drawOneLayer(outPoint));
    const isPointOnLine2 = turf.booleanPointOnLine(outPoint, line1);

    info += `点1与线1关系：${isPointOnLine1}, 其它与线1关系: ${isPointOnLine2}\r\n`;

    polygon1 = turf.polygon(
    [
        [
            [108.3, 22.86], 
            [108.4, 22.86], 
            [108.4, 22.9], 
            [108.3, 22.9], 
            [108.3, 22.86]
        ]
    ], {color: "#0000FF"}
    );

    polygon2 = turf.polygon(
    [
        [
            [108.349228,22.918555],
            [108.378067,22.963451],
            [108.476257,22.950806],
            [108.479004,22.893888],
            [108.440552,22.855929],
            // [108.417892,22.909701], // 删除此坐标，两多边形相交
            [108.349228,22.918555]
        ]
    ], {color: "#0000FF"}
    );

    addToLayers(drawOneLayer(polygon1));
    addToLayers(drawOneLayer(polygon2));

    inPoint = turf.point([108.304596,22.895786], {name: "内点"})
    addToLayers(drawOneLayer(inPoint));

    const isPointInPoly = turf.booleanPointInPolygon(inPoint, polygon1);
    const isOverlap = turf.booleanOverlap(polygon1, polygon2);

    info += `点与面关系：${isPointInPoly}, 面与面的关系: ${isOverlap}\r\n`;
    return info;
}

/////// 交集、并集、差集
function turf_demo5() {
    var info = ""

    polygon1 = turf.polygon(
    [
        [
            [108.3, 22.86], 
            [108.4, 22.86], 
            [108.4, 22.9], 
            [108.3, 22.9], 
            [108.3, 22.86]
        ]
    ], {color: "#0000FF"}
    );

    polygon2 = turf.polygon(
    [
        [
            [108.325195,22.887562],
            [108.327942,22.872379],
            [108.422012,22.864155],
            [108.446732,22.879971],
            [108.417892,22.891990],
            [108.325195,22.887562]
        ]
    ], {color: "#0000FF"}
    );

    // 根据需要决定显示与否
    addToLayers(drawOneLayer(polygon1));
    addToLayers(drawOneLayer(polygon2));


    // turf 6 版本接口可用
    // const intersection = turf.intersect(polygon1, polygon2);
    // 以下为turf 7 版本接口
    // 交集
    const intersection = turf.intersect(turf.featureCollection([polygon1, polygon2]), {properties: {color: "#FF0000"}});
    // 并集
    const union = turf.union(turf.featureCollection([polygon1, polygon2]), {properties: {color: "#008000"}});
    // 差集
    const difference = turf.difference(turf.featureCollection([polygon1, polygon2]), {properties: {color: "#FF0000"}});

    // 根据需要决定显示与否
    addToLayers(drawOneLayer(intersection));
    addToLayers(drawOneLayer(union));
    addToLayers(drawOneLayer(difference));

    return info;
}


function showSimplifyTurf(inputStr) {
    console.log('简化路线:', inputStr);
    const geojsonData = JSON.parse(inputStr);

    var options = { tolerance: 0.0001, highQuality: true, mutate: true };
    var simplified = turf.simplify(geojsonData, options);
    
    var object = drawOneLayer(simplified);
    addToLayers(object);
    mymap.fitBounds(object.getBounds());

    var ouput = JSON.stringify(simplified, null, 2)
    return `简化成功\r\n${ouput}`
}

function clearMap() {
    if (currentLayer) {
        mymap.removeLayer(currentLayer);
        currentLayer = null;
    }
    clearAllLayers();
}

function main() {
    showMap();
}

// last....
main();

</script>

</html>